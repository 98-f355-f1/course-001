#!/usr/bin/env ruby

require "optparse"

require_relative "../lib/file_details"

## Parse command line arguments

parser = OptionParser.new
params = {}

parser.on("-a") { params[:all_files]    = true }
parser.on("-l") { params[:show_details] = true }

begin
  params[:files] = parser.parse(ARGV)
rescue OptionParser::InvalidOption => e
  bad_flag = e.message[/invalid option: -(.*)/, 1]
  abort "ls: illegal option -- #{bad_flag}\n"+
        "usage: ls [-ABCFGHLOPRSTUWabcdefghiklmnopqrstuwx1] [file ...]"
end

## Figure out which files to list

dir_listing  = params[:files].empty? ||
               params[:files].first
               (params[:files].length == 1 && File.directory?(params[:files][0]))

if dir_listing 
  Dir.chdir(params[:files][0]) if params[:files].any?

  dotfiles = params[:all_files] ? File::FNM_DOTMATCH : 0

  files = Dir.glob("*", dotfiles) 
else
  files = params[:files]
end

files.each do |f|
  abort("ls: #{f}: No such file or directory") unless File.exist?(f)
end

## Produce the output

details_list = FileDetails::List.new(files)

if params[:show_details] && dir_listing
  puts "total #{details_list.blocks}"
end

details_list.each do |details|
  if params[:show_details]
    puts [details[:permissions],
          details[:links].to_s.rjust(details_list.column_widths[:links] + 1, " "),          
          "#{details[:owner]}  #{details[:group]}",
          details[:size].to_s.rjust(details_list.column_widths[:size] + 1, " "),
          details[:mtime],
          details[:name]].join(" ")
  else
    puts details[:name]
  end
end
